#pragma config(Sensor, in7,    Accelerometer,  sensorAnalog)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define errorMeasurement 10
//Motors and sensors setup
#define MOTOR_driveLF port4
#define MOTOR_driveLM port9
#define MOTOR_driveLB port10

#define MOTOR_mobileGoalL port5
#define MOTOR_coneIntake port3
#define MOTOR_arm port8
#define MOTOR_mobileGoalR port6

#define MOTOR_driveRB port1
#define MOTOR_driveRM port2
#define MOTOR_driveRF port7

#define SENSOR_potArm in1
#define SENSOR_potMogo in2
#define SENSOR_powerExpander in3
#define SENSOR_encoderL dgtl1
#define SENSOR_encoderR dgtl3
#define SENSOR_gyro in8

//Joystick setup
#define JOYSTICK_driveF Ch3
#define JOYSTICK_driveS Ch1
#define JOYSTICK_arm Ch2
#define JOYSTICK_mobileGoalE Btn6D
#define JOYSTICK_mobileGoalR Btn6U
#define JOYSTICK_coneIntakeP Btn5U
#define JOYSTICK_coneIntakeD Btn5D

void init();

float VtoIn2(float inNumber){
	//Convert inNumber to volts to G to inches/second^. Finally take into account an error margin
	return 386.088582677165 * (2.22222 * ((inNumber * 5.0)/4096.0) - 5.55555);
}

float calculateSpeedFromVA(float vi, float a, float t){
	return (vi + a*t);
}

task main(){

	init();

	int originalY = 0;
	if(true){
		int C = 1, total = 0;
		for(; C<1000; C++)total += SensorValue[Accelerometer];
		originalY = ceil(total/C);
	}

	delay(1000);
	float kg = 0.005, estimate = originalY, previousEstimate = originalY, errorEstimate = 0.000001, previousErrorEstimate = 0.000001, speed = 0, DISTANCE = 0;
	int measurement = SensorValue[Accelerometer];
	clearDebugStream();
	datalogClear();

	while(true){
		kg = 0.15;
		//if((errorEstimate - errorMeasurement) != 0 )	kg = errorEstimate/(errorEstimate - errorMeasurement);
		measurement = SensorValue[Accelerometer];
		estimate = round(previousEstimate + (kg * (measurement-previousEstimate)));
		errorEstimate = (1-kg) * previousErrorEstimate;
		previousEstimate = estimate;	previousErrorEstimate = errorEstimate;

		float acceleration = VtoIn2(fabs(estimate) - (fabs(originalY)-2048));

		DISTANCE += (0.5*acceleration*0.0004) + (speed*0.02);

		speed = calculateSpeedFromVA(speed, acceleration, 0.02);

		//Move motors
		if(DISTANCE < 24){
			motor[MOTOR_driveLF] = motor[MOTOR_driveLM] = motor[MOTOR_driveLB] = (vexRT[JOYSTICK_driveF] + vexRT[JOYSTICK_driveS]);
			motor[MOTOR_driveRF] = motor[MOTOR_driveRM] = motor[MOTOR_driveRB] = (vexRT[JOYSTICK_driveF] - vexRT[JOYSTICK_driveS]);
		}
		else break;

		datalogAddValue(0, measurement);
		datalogAddValue(1, estimate);
		datalogAddValue(2, acceleration);
		datalogAddValue(3, DISTANCE);
		writeDebugStreamLine("originalY= %d,\testimate = %f,\tmeasurement = %f\tacceleration = %f,\tdistance = %f", originalY, estimate, measurement, acceleration,  DISTANCE);
		delay(20);
	}

	for(int C = 0; C<10; C++){
		motor[MOTOR_driveLF] = motor[MOTOR_driveLM] = motor[MOTOR_driveLB] = -127;
		motor[MOTOR_driveRF] = motor[MOTOR_driveRM] = motor[MOTOR_driveRB] = -127;
		delay(20);
	}

}

void init(){
	//Initiate motors with their types
	motorType[MOTOR_driveLF] = motorType[MOTOR_driveLM] = motorType[MOTOR_driveLB] =  tmotorVex393TurboSpeed_HBridge;
	motorType[MOTOR_mobileGoalL] = motorType[MOTOR_mobileGoalR] = tmotorVex393_HBridge;
	motorType[MOTOR_coneIntake] = motorType[MOTOR_arm] = tmotorVex393_HBridge;
	motorType[MOTOR_driveRB] = motorType[MOTOR_driveRM] = motorType[MOTOR_driveRF] = tmotorVex393TurboSpeed_HBridge;

	//Invert necessary motors
	bMotorReflected[MOTOR_driveLF] = false;
	bMotorReflected[MOTOR_driveLM] = false;
	bMotorReflected[MOTOR_driveLB] = true;
	bMotorReflected[MOTOR_mobileGoalL] = true;
	bMotorReflected[MOTOR_coneIntake] = true;
	bMotorReflected[MOTOR_arm] = true;
	bMotorReflected[MOTOR_mobileGoalR] = false;
	bMotorReflected[MOTOR_driveRB] = false;
	bMotorReflected[MOTOR_driveRM] = true;
	bMotorReflected[MOTOR_driveRF] = true;

}
